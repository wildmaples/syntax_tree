<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class PrettyPrint - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#class-PrettyPrint-label-Usage">Usage</a>
    <li><a href="#class-PrettyPrint-label-Bugs">Bugs</a>
    <li><a href="#class-PrettyPrint-label-References">References</a>
    <li><a href="#class-PrettyPrint-label-Author">Author</a>
  </ul>
</div>


  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link">Object
</div>

    
    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-format">::format</a>
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-c-singleline_format">::singleline_format</a>
    <li ><a href="#method-i-break_parent">#break_parent</a>
    <li ><a href="#method-i-breakable">#breakable</a>
    <li ><a href="#method-i-current_group">#current_group</a>
    <li ><a href="#method-i-fill_breakable">#fill_breakable</a>
    <li ><a href="#method-i-flush">#flush</a>
    <li ><a href="#method-i-group">#group</a>
    <li ><a href="#method-i-if_break">#if_break</a>
    <li ><a href="#method-i-indent">#indent</a>
    <li ><a href="#method-i-line_suffix">#line_suffix</a>
    <li ><a href="#method-i-nest">#nest</a>
    <li ><a href="#method-i-text">#text</a>
    <li ><a href="#method-i-trim">#trim</a>
    <li ><a href="#method-i-with_target">#with_target</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-PrettyPrint">
  <h1 id="class-PrettyPrint" class="class">
    class PrettyPrint
  </h1>

  <section class="description">
    
<p>This class implements a pretty printing algorithm. It finds line breaks and nice indentations for grouped structure.</p>

<p>By default, the class assumes that primitive elements are strings and each byte in the strings is a single column in width. But it can be used for other situations by giving suitable arguments for some methods:</p>
<ul><li>
<p>newline object and space generation block for <a href="PrettyPrint.html#method-c-new"><code>PrettyPrint.new</code></a></p>
</li><li>
<p>optional width argument for <a href="PrettyPrint.html#method-i-text"><code>PrettyPrint#text</code></a></p>
</li><li>
<p><a href="PrettyPrint.html#method-i-breakable"><code>PrettyPrint#breakable</code></a></p>
</li></ul>

<p>There are several candidate uses:</p>
<ul><li>
<p>text formatting using proportional fonts</p>
</li><li>
<p>multibyte characters which has columns different to number of bytes</p>
</li><li>
<p>non-string formatting</p>
</li></ul>

<h2 id="class-PrettyPrint-label-Usage">Usage<span><a href="#class-PrettyPrint-label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To use this module, you will need to generate a tree of print nodes that represent indentation and newline behavior before it gets sent to the printer. Each node has different semantics, depending on the desired output.</p>

<p>The most basic node is a <a href="PrettyPrint/Text.html"><code>Text</code></a> node. This represents plain text content that cannot be broken up even if it doesn’t fit on one line. You would create one of those with the text method, as in:</p>

<pre class="ruby"><span class="ruby-constant">PrettyPrint</span>.<span class="ruby-identifier">format</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">q</span><span class="ruby-operator">|</span> <span class="ruby-identifier">q</span>.<span class="ruby-identifier">text</span>(<span class="ruby-string">&#39;my content&#39;</span>) }
</pre>

<p>No matter what the desired output width is, the output for the snippet above will always be the same.</p>

<p>If you want to allow the printer to break up the content on the space character when there isn’t enough width for the full string on the same line, you can use the <a href="PrettyPrint/Breakable.html"><code>Breakable</code></a> and <a href="PrettyPrint/Group.html"><code>Group</code></a> nodes. For example:</p>

<pre class="ruby"><span class="ruby-constant">PrettyPrint</span>.<span class="ruby-identifier">format</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">q</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">q</span>.<span class="ruby-identifier">group</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">q</span>.<span class="ruby-identifier">text</span>(<span class="ruby-string">&#39;my&#39;</span>)
    <span class="ruby-identifier">q</span>.<span class="ruby-identifier">breakable</span>
    <span class="ruby-identifier">q</span>.<span class="ruby-identifier">text</span>(<span class="ruby-string">&#39;content&#39;</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Now, if everything fits on one line (depending on the maximum width specified) then it will be the same output as the first example. If, however, there is not enough room on the line, then you will get two lines of output, one for the first string and one for the second.</p>

<p>There are other nodes for the print tree as well, described in the documentation below. They control alignment, indentation, conditional formatting, and more.</p>

<h2 id="class-PrettyPrint-label-Bugs">Bugs<span><a href="#class-PrettyPrint-label-Bugs">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p>Box based formatting?</p>
</li></ul>

<p>Report any bugs at <a href="http://bugs.ruby-lang.org">bugs.ruby-lang.org</a></p>

<h2 id="class-PrettyPrint-label-References">References<span><a href="#class-PrettyPrint-label-References">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Christian Lindig, Strictly Pretty, March 2000, <a href="https://lindig.github.io/papers/strictly-pretty-2000.pdf">lindig.github.io/papers/strictly-pretty-2000.pdf</a></p>

<p>Philip Wadler, A prettier printer, March 1998, <a href="https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf">homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf</a></p>

<h2 id="class-PrettyPrint-label-Author">Author<span><a href="#class-PrettyPrint-label-Author">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Tanaka Akira &lt;akr@fsij.org&gt;</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">


    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
        <dt id="DEFAULT_GENSPACE">DEFAULT_GENSPACE
        <dd><p>When generating spaces after a newline for indentation, by default we generate one space per character needed for indentation. You can change this behavior (for instance to use tabs) by passing a different genspace procedure.</p>
        <dt id="DEFAULT_NEWLINE">DEFAULT_NEWLINE
        <dd><p>When printing, you can optionally specify the value that should be used whenever a group needs to be broken onto multiple lines. In this case the default is n.</p>
        <dt id="MODE_BREAK">MODE_BREAK
        <dd><p>There are two modes in printing, break and flat. When we’re in break mode, any lines will use their newline, any if-breaks will use their break contents, etc.</p>
        <dt id="MODE_FLAT">MODE_FLAT
        <dd><p>This is another print mode much like <a href="PrettyPrint.html#MODE_BREAK"><code>MODE_BREAK</code></a>. When we’re in flat mode, we attempt to print everything on one line until we either hit a broken group, a forced line, or the maximum width.</p>
      </dl>
    </section>

    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      <div id="attribute-i-buffer" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">buffer</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        <p>This is an output buffer that wraps the output object and provides additional functionality depending on its type.</p>

<p>This defaults to <a href="PrettyPrint/Buffer/StringBuffer.html#method-c-new"><code>Buffer::StringBuffer.new</code></a>(“”.dup)</p>
        </div>
      </div>
      <div id="attribute-i-genspace" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">genspace</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        <p>An object that responds to call that takes one argument, of an Integer, and returns the corresponding number of spaces.</p>

<p>By default this is: -&gt;(n) { ‘ ’ * n }</p>
        </div>
      </div>
      <div id="attribute-i-groups" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">groups</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        <p>The stack of groups that are being printed.</p>
        </div>
      </div>
      <div id="attribute-i-maxwidth" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">maxwidth</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        <p>The maximum width of a line, before it is separated in to a newline</p>

<p>This defaults to 80, and should be an Integer</p>
        </div>
      </div>
      <div id="attribute-i-newline" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">newline</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        <p>The value that is appended to <code>output</code> to add a new line.</p>

<p>This defaults to “n”, and should be String</p>
        </div>
      </div>
      <div id="attribute-i-output" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">output</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        <p>The output object. It represents the final destination of the contents of the print tree. It should respond to &lt;&lt;.</p>

<p>This defaults to “”.dup</p>
        </div>
      </div>
      <div id="attribute-i-target" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">target</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        <p>The current array of contents that calls to methods that generate print tree nodes will append to.</p>
        </div>
      </div>
    </section>


     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-format" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">format</span><span
            class="method-args">( output = &quot;&quot;.dup, maxwidth = 80, newline = DEFAULT_NEWLINE, genspace = DEFAULT_GENSPACE ) { |q| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>This is a convenience method which is same as follows:</p>

<pre class="ruby"><span class="ruby-keyword">begin</span>
  <span class="ruby-identifier">q</span> = <span class="ruby-constant">PrettyPrint</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">maxwidth</span>, <span class="ruby-identifier">newline</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">genspace</span>)
  <span class="ruby-operator">...</span>
  <span class="ruby-identifier">q</span>.<span class="ruby-identifier">flush</span>
  <span class="ruby-identifier">output</span>
<span class="ruby-keyword">end</span>
</pre>

          <div class="method-source-code" id="format-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 601</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">format</span>(
  <span class="ruby-identifier">output</span> = <span class="ruby-string">&quot;&quot;</span>.<span class="ruby-identifier">dup</span>,
  <span class="ruby-identifier">maxwidth</span> = <span class="ruby-value">80</span>,
  <span class="ruby-identifier">newline</span> = <span class="ruby-constant">DEFAULT_NEWLINE</span>,
  <span class="ruby-identifier">genspace</span> = <span class="ruby-constant">DEFAULT_GENSPACE</span>
)
  <span class="ruby-identifier">q</span> = <span class="ruby-identifier">new</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">maxwidth</span>, <span class="ruby-identifier">newline</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">genspace</span>)
  <span class="ruby-keyword">yield</span> <span class="ruby-identifier">q</span>
  <span class="ruby-identifier">q</span>.<span class="ruby-identifier">flush</span>
  <span class="ruby-identifier">output</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-c-new" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">( output = &quot;&quot;.dup, maxwidth = 80, newline = DEFAULT_NEWLINE, &amp;genspace )</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Creates a buffer for pretty printing.</p>

<p><code>output</code> is an output target. If it is not specified, ” is assumed. It should have a &lt;&lt; method which accepts the first argument <code>obj</code> of <a href="PrettyPrint.html#method-i-text"><code>PrettyPrint#text</code></a>, the first argument <code>separator</code> of <a href="PrettyPrint.html#method-i-breakable"><code>PrettyPrint#breakable</code></a>, the first argument <code>newline</code> of <a href="PrettyPrint.html#method-c-new"><code>PrettyPrint.new</code></a>, and the result of a given block for <a href="PrettyPrint.html#method-c-new"><code>PrettyPrint.new</code></a>.</p>

<p><code>maxwidth</code> specifies maximum line length. If it is not specified, 80 is assumed. However actual outputs may overflow <code>maxwidth</code> if long non-breakable texts are provided.</p>

<p><code>newline</code> is used for line breaks. “n” is used if it is not specified.</p>

<p>The block is used to generate spaces. -&gt;(n) { ‘ ’ * n } is used if it is not given.</p>

          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 682</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(
  <span class="ruby-identifier">output</span> = <span class="ruby-string">&quot;&quot;</span>.<span class="ruby-identifier">dup</span>,
  <span class="ruby-identifier">maxwidth</span> = <span class="ruby-value">80</span>,
  <span class="ruby-identifier">newline</span> = <span class="ruby-constant">DEFAULT_NEWLINE</span>,
  <span class="ruby-operator">&amp;</span><span class="ruby-identifier">genspace</span>
)
  <span class="ruby-ivar">@output</span> = <span class="ruby-identifier">output</span>
  <span class="ruby-ivar">@buffer</span> = <span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">for</span>(<span class="ruby-identifier">output</span>)
  <span class="ruby-ivar">@maxwidth</span> = <span class="ruby-identifier">maxwidth</span>
  <span class="ruby-ivar">@newline</span> = <span class="ruby-identifier">newline</span>
  <span class="ruby-ivar">@genspace</span> = <span class="ruby-identifier">genspace</span> <span class="ruby-operator">||</span> <span class="ruby-constant">DEFAULT_GENSPACE</span>
  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-c-singleline_format" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">singleline_format</span><span
            class="method-args">( output = &quot;&quot;.dup, maxwidth = nil, newline = nil, genspace = nil ) { |q| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>This is similar to <a href="PrettyPrint.html#method-c-format"><code>PrettyPrint::format</code></a> but the result has no breaks.</p>

<p><code>maxwidth</code>, <code>newline</code> and <code>genspace</code> are ignored.</p>

<p>The invocation of <code>breakable</code> in the block doesn’t break a line and is treated as just an invocation of <code>text</code>.</p>

          <div class="method-source-code" id="singleline_format-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 620</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">singleline_format</span>(
  <span class="ruby-identifier">output</span> = <span class="ruby-string">&quot;&quot;</span>.<span class="ruby-identifier">dup</span>,
  <span class="ruby-identifier">maxwidth</span> = <span class="ruby-keyword">nil</span>,
  <span class="ruby-identifier">newline</span> = <span class="ruby-keyword">nil</span>,
  <span class="ruby-identifier">genspace</span> = <span class="ruby-keyword">nil</span>
)
  <span class="ruby-identifier">q</span> = <span class="ruby-constant">SingleLine</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">output</span>)
  <span class="ruby-keyword">yield</span> <span class="ruby-identifier">q</span>
  <span class="ruby-identifier">output</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-break_parent" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">break_parent</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>This inserts a <a href="PrettyPrint/BreakParent.html"><code>BreakParent</code></a> node into the print tree which forces the surrounding and all parent group nodes to break.</p>

          <div class="method-source-code" id="break_parent-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 901</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">break_parent</span>
  <span class="ruby-identifier">doc</span> = <span class="ruby-constant">BreakParent</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>

  <span class="ruby-identifier">groups</span>.<span class="ruby-identifier">reverse_each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">group</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">group</span>.<span class="ruby-identifier">break?</span>
    <span class="ruby-identifier">group</span>.<span class="ruby-identifier">break</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">doc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-breakable" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">breakable</span><span
            class="method-args">( separator = &quot; &quot;, width = separator.length, indent: true, force: false )</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>This says “you can break a line here if necessary”, and a <code>width</code>-column text <code>separator</code> is inserted if a line is not broken at the point.</p>

<p>If <code>separator</code> is not specified, ‘ ’ is used.</p>

<p>If <code>width</code> is not specified, <code>separator.length</code> is used. You will have to specify this when <code>separator</code> is a multibyte character, for example.</p>

<p>By default, if the surrounding group is broken and a newline is inserted, the printer will indent the subsequent line up to the current level of indentation. You can disable this behavior with the <code>indent</code> argument if that’s not desired (rare).</p>

<p>By default, when you insert a <a href="PrettyPrint/Breakable.html"><code>Breakable</code></a> into the print tree, it only breaks the surrounding group when the group’s contents cannot fit onto the remaining space of the current line. You can force it to break the surrounding group instead if you always want the newline with the <code>force</code> argument.</p>

          <div class="method-source-code" id="breakable-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 885</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable</span>(
  <span class="ruby-identifier">separator</span> = <span class="ruby-string">&quot; &quot;</span>,
  <span class="ruby-identifier">width</span> = <span class="ruby-identifier">separator</span>.<span class="ruby-identifier">length</span>,
  <span class="ruby-value">indent:</span> <span class="ruby-keyword">true</span>,
  <span class="ruby-value">force:</span> <span class="ruby-keyword">false</span>
)
  <span class="ruby-identifier">doc</span> = <span class="ruby-constant">Breakable</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">separator</span>, <span class="ruby-identifier">width</span>, <span class="ruby-value">indent:</span> <span class="ruby-identifier">indent</span>, <span class="ruby-value">force:</span> <span class="ruby-identifier">force</span>)

  <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>
  <span class="ruby-identifier">break_parent</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">force</span>

  <span class="ruby-identifier">doc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-current_group" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">current_group</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the group most recently added to the stack.</p>

<p>Contrived example:</p>

<pre>out = &quot;&quot;
=&gt; &quot;&quot;
q = PrettyPrint.new(out)
=&gt; #&lt;PrettyPrint:0x0&gt;
q.group {
  q.text q.current_group.inspect
  q.text q.newline
  q.group(q.current_group.depth + 1) {
    q.text q.current_group.inspect
    q.text q.newline
    q.group(q.current_group.depth + 1) {
      q.text q.current_group.inspect
      q.text q.newline
      q.group(q.current_group.depth + 1) {
        q.text q.current_group.inspect
        q.text q.newline
      }
    }
  }
}
=&gt; 284
 puts out
#&lt;PrettyPrint::Group:0x0 @depth=1&gt;
#&lt;PrettyPrint::Group:0x0 @depth=2&gt;
#&lt;PrettyPrint::Group:0x0 @depth=3&gt;
#&lt;PrettyPrint::Group:0x0 @depth=4&gt;</pre>

          <div class="method-source-code" id="current_group-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 725</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current_group</span>
  <span class="ruby-identifier">groups</span>.<span class="ruby-identifier">last</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-fill_breakable" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">fill_breakable</span><span
            class="method-args">(separator = &quot; &quot;, width = separator.length)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>This is similar to <a href="PrettyPrint.html#method-i-breakable"><code>breakable</code></a> except the decision to break or not is determined individually.</p>

<p>Two <a href="PrettyPrint.html#method-i-fill_breakable"><code>fill_breakable</code></a> under a group may cause 4 results: (break,break), (break,non-break), (non-break,break), (non-break,non-break). This is different to <a href="PrettyPrint.html#method-i-breakable"><code>breakable</code></a> because two <a href="PrettyPrint.html#method-i-breakable"><code>breakable</code></a> under a group may cause 2 results: (break,break), (non-break,non-break).</p>

<p>The text <code>separator</code> is inserted if a line is not broken at this point.</p>

<p>If <code>separator</code> is not specified, ‘ ’ is used.</p>

<p>If <code>width</code> is not specified, <code>separator.length</code> is used. You will have to specify this when <code>separator</code> is a multibyte character, for example.</p>

          <div class="method-source-code" id="fill_breakable-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 927</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fill_breakable</span>(<span class="ruby-identifier">separator</span> = <span class="ruby-string">&quot; &quot;</span>, <span class="ruby-identifier">width</span> = <span class="ruby-identifier">separator</span>.<span class="ruby-identifier">length</span>)
  <span class="ruby-identifier">group</span> { <span class="ruby-identifier">breakable</span>(<span class="ruby-identifier">separator</span>, <span class="ruby-identifier">width</span>) }
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-flush" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">flush</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Flushes all of the generated print tree onto the output buffer, then clears the generated tree from memory.</p>

          <div class="method-source-code" id="flush-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 731</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flush</span>
  <span class="ruby-comment"># First, get the root group, since we placed one at the top to begin with.</span>
  <span class="ruby-identifier">doc</span> = <span class="ruby-identifier">groups</span>.<span class="ruby-identifier">first</span>

  <span class="ruby-comment"># This represents how far along the current line we are. It gets reset</span>
  <span class="ruby-comment"># back to 0 when we encounter a newline.</span>
  <span class="ruby-identifier">position</span> = <span class="ruby-value">0</span>

  <span class="ruby-comment"># This is our command stack. A command consists of a triplet of an</span>
  <span class="ruby-comment"># indentation level, the mode (break or flat), and a doc node.</span>
  <span class="ruby-identifier">commands</span> = [[<span class="ruby-constant">IndentLevel</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">genspace:</span> <span class="ruby-identifier">genspace</span>), <span class="ruby-constant">MODE_BREAK</span>, <span class="ruby-identifier">doc</span>]]

  <span class="ruby-comment"># This is a small optimization boolean. It keeps track of whether or not</span>
  <span class="ruby-comment"># when we hit a group node we should check if it fits on the same line.</span>
  <span class="ruby-identifier">should_remeasure</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-comment"># This is a separate command stack that includes the same kind of triplets</span>
  <span class="ruby-comment"># as the commands variable. It is used to keep track of things that should</span>
  <span class="ruby-comment"># go at the end of printed lines once the other doc nodes are accounted for.</span>
  <span class="ruby-comment"># Typically this is used to implement comments.</span>
  <span class="ruby-identifier">line_suffixes</span> = []

  <span class="ruby-comment"># This is a special sort used to order the line suffixes by both the</span>
  <span class="ruby-comment"># priority set on the line suffix and the index it was in the original</span>
  <span class="ruby-comment"># array.</span>
  <span class="ruby-identifier">line_suffix_sort</span> = <span class="ruby-operator">-&gt;</span>(<span class="ruby-identifier">line_suffix</span>) <span class="ruby-keyword">do</span>
    [<span class="ruby-operator">-</span><span class="ruby-identifier">line_suffix</span>.<span class="ruby-identifier">last</span>, <span class="ruby-operator">-</span><span class="ruby-identifier">line_suffixes</span>.<span class="ruby-identifier">index</span>(<span class="ruby-identifier">line_suffix</span>)]
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># This is a linear stack instead of a mutually recursive call defined on</span>
  <span class="ruby-comment"># the individual doc nodes for efficiency.</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">commands</span>.<span class="ruby-identifier">any?</span>
    <span class="ruby-identifier">indent</span>, <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">doc</span> = <span class="ruby-identifier">commands</span>.<span class="ruby-identifier">pop</span>

    <span class="ruby-keyword">case</span> <span class="ruby-identifier">doc</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Text</span>
      <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">objects</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">object</span><span class="ruby-operator">|</span> <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">object</span> }
      <span class="ruby-identifier">position</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">width</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Array</span>
      <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">reverse_each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">part</span><span class="ruby-operator">|</span> <span class="ruby-identifier">commands</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">indent</span>, <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">part</span>] }
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Indent</span>
      <span class="ruby-identifier">commands</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">indent</span>.<span class="ruby-identifier">indent</span>, <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>]
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Align</span>
      <span class="ruby-identifier">commands</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">indent</span>.<span class="ruby-identifier">align</span>(<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">indent</span>), <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>]
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Trim</span>
      <span class="ruby-identifier">position</span> <span class="ruby-operator">-=</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">trim!</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Group</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">mode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">MODE_FLAT</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">should_remeasure</span>
        <span class="ruby-identifier">commands</span> <span class="ruby-operator">&lt;&lt;</span>
          [<span class="ruby-identifier">indent</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">break?</span> <span class="ruby-operator">?</span> <span class="ruby-constant">MODE_BREAK</span> <span class="ruby-operator">:</span> <span class="ruby-constant">MODE_FLAT</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>]
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">should_remeasure</span> = <span class="ruby-keyword">false</span>
        <span class="ruby-identifier">next_cmd</span> = [<span class="ruby-identifier">indent</span>, <span class="ruby-constant">MODE_FLAT</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>]

        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">doc</span>.<span class="ruby-identifier">break?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">fits?</span>(<span class="ruby-identifier">next_cmd</span>, <span class="ruby-identifier">commands</span>, <span class="ruby-identifier">maxwidth</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">position</span>)
          <span class="ruby-identifier">commands</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">next_cmd</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">commands</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">indent</span>, <span class="ruby-constant">MODE_BREAK</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>]
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">IfBreak</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">mode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">MODE_BREAK</span>
        <span class="ruby-identifier">commands</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">indent</span>, <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">break_contents</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">break_contents</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">mode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">MODE_FLAT</span>
        <span class="ruby-identifier">commands</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">indent</span>, <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">flat_contents</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">flat_contents</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">LineSuffix</span>
      <span class="ruby-identifier">line_suffixes</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">indent</span>, <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>, <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">priority</span>]
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Breakable</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">mode</span> <span class="ruby-operator">==</span> <span class="ruby-constant">MODE_FLAT</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">force?</span>
          <span class="ruby-comment"># This line was forced into the output even if we were in flat mode,</span>
          <span class="ruby-comment"># so we need to tell the next group that no matter what, it needs to</span>
          <span class="ruby-comment"># remeasure because the previous measurement didn&#39;t accurately</span>
          <span class="ruby-comment"># capture the entire expression (this is necessary for nested</span>
          <span class="ruby-comment"># groups).</span>
          <span class="ruby-identifier">should_remeasure</span> = <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">separator</span>
          <span class="ruby-identifier">position</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">width</span>
          <span class="ruby-keyword">next</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># If there are any commands in the line suffix buffer, then we&#39;re going</span>
      <span class="ruby-comment"># to flush them now, as we are about to add a newline.</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">line_suffixes</span>.<span class="ruby-identifier">any?</span>
        <span class="ruby-identifier">commands</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">indent</span>, <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">doc</span>]
        <span class="ruby-identifier">commands</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">line_suffixes</span>.<span class="ruby-identifier">sort_by</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">line_suffix_sort</span>)
        <span class="ruby-identifier">line_suffixes</span> = []
        <span class="ruby-keyword">next</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">doc</span>.<span class="ruby-identifier">indent?</span>
        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">newline</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">root</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">value</span>
          <span class="ruby-identifier">position</span> = <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">length</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">position</span> = <span class="ruby-value">0</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">position</span> <span class="ruby-operator">-=</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">trim!</span>
        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">newline</span>
        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">value</span>
        <span class="ruby-identifier">position</span> = <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">length</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">BreakParent</span>
      <span class="ruby-comment"># do nothing</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-comment"># Special case where the user has defined some way to get an extra doc</span>
      <span class="ruby-comment"># node that we don&#39;t explicitly support into the list. In this case</span>
      <span class="ruby-comment"># we&#39;re going to assume it&#39;s 0-width and just append it to the output</span>
      <span class="ruby-comment"># buffer.</span>
      <span class="ruby-comment">#</span>
      <span class="ruby-comment"># This is useful behavior for putting marker nodes into the list so that</span>
      <span class="ruby-comment"># you can know how things are getting mapped before they get printed.</span>
      <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">commands</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line_suffixes</span>.<span class="ruby-identifier">any?</span>
      <span class="ruby-identifier">commands</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">line_suffixes</span>.<span class="ruby-identifier">sort_by</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">line_suffix_sort</span>)
      <span class="ruby-identifier">line_suffixes</span> = []
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Reset the group stack and target array so that this pretty printer object</span>
  <span class="ruby-comment"># can continue to be used before calling flush again if desired.</span>
  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-group" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">group</span><span
            class="method-args">( indent = 0, open_object = &quot;&quot;, close_object = &quot;&quot;, open_width = open_object.length, close_width = close_object.length ) { || ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Groups line break hints added in the block. The line break hints are all to be used or not.</p>

<p>If <code>indent</code> is specified, the method call is regarded as nested by nest(indent) { … }.</p>

<p>If <code>open_object</code> is specified, <code>text(open_object, open_width)</code> is called before grouping. If <code>close_object</code> is specified, <code>text(close_object, close_width)</code> is called after grouping.</p>

          <div class="method-source-code" id="group-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 955</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">group</span>(
  <span class="ruby-identifier">indent</span> = <span class="ruby-value">0</span>,
  <span class="ruby-identifier">open_object</span> = <span class="ruby-string">&quot;&quot;</span>,
  <span class="ruby-identifier">close_object</span> = <span class="ruby-string">&quot;&quot;</span>,
  <span class="ruby-identifier">open_width</span> = <span class="ruby-identifier">open_object</span>.<span class="ruby-identifier">length</span>,
  <span class="ruby-identifier">close_width</span> = <span class="ruby-identifier">close_object</span>.<span class="ruby-identifier">length</span>
)
  <span class="ruby-identifier">text</span>(<span class="ruby-identifier">open_object</span>, <span class="ruby-identifier">open_width</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">open_object</span> <span class="ruby-operator">!=</span> <span class="ruby-string">&quot;&quot;</span>

  <span class="ruby-identifier">doc</span> = <span class="ruby-constant">Group</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">groups</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">depth</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)
  <span class="ruby-identifier">groups</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>
  <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>

  <span class="ruby-identifier">with_target</span>(<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>) <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">indent</span> <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">nest</span>(<span class="ruby-identifier">indent</span>) { <span class="ruby-keyword">yield</span> }
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">yield</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">groups</span>.<span class="ruby-identifier">pop</span>
  <span class="ruby-identifier">text</span>(<span class="ruby-identifier">close_object</span>, <span class="ruby-identifier">close_width</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">close_object</span> <span class="ruby-operator">!=</span> <span class="ruby-string">&quot;&quot;</span>

  <span class="ruby-identifier">doc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-if_break" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">if_break</span><span
            class="method-args">() { || ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Inserts an <a href="PrettyPrint/IfBreak.html"><code>IfBreak</code></a> node with the contents of the block being added to its list of nodes that should be printed if the surrounding node breaks. If it doesn’t, then you can specify the contents to be printed with the if_flat method used on the return object from this method. For example,</p>

<pre class="ruby"><span class="ruby-identifier">q</span>.<span class="ruby-identifier">if_break</span> { <span class="ruby-identifier">q</span>.<span class="ruby-identifier">text</span>(<span class="ruby-string">&#39;do&#39;</span>) }.<span class="ruby-identifier">if_flat</span> { <span class="ruby-identifier">q</span>.<span class="ruby-identifier">text</span>(<span class="ruby-string">&#39;{&#39;</span>) }
</pre>

<p>In the example above, if the surrounding group is broken it will print ‘do’ and if it is not it will print ‘{’.</p>

          <div class="method-source-code" id="if_break-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 1006</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_break</span>
  <span class="ruby-identifier">doc</span> = <span class="ruby-constant">IfBreak</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>

  <span class="ruby-identifier">with_target</span>(<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">break_contents</span>) { <span class="ruby-keyword">yield</span> }
  <span class="ruby-constant">IfBreakBuilder</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">doc</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-indent" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">indent</span><span
            class="method-args">() { || ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Very similar to the <a href="PrettyPrint.html#method-i-nest"><code>nest</code></a> method, this indents the nested content by one level by inserting an <a href="PrettyPrint/Indent.html"><code>Indent</code></a> node into the print tree. The contents of the node are determined by the block.</p>

          <div class="method-source-code" id="indent-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 1017</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indent</span>
  <span class="ruby-identifier">doc</span> = <span class="ruby-constant">Indent</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>

  <span class="ruby-identifier">with_target</span>(<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>) { <span class="ruby-keyword">yield</span> }
  <span class="ruby-identifier">doc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-line_suffix" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">line_suffix</span><span
            class="method-args">(priority: LineSuffix::DEFAULT_PRIORITY) { || ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Inserts a <a href="PrettyPrint/LineSuffix.html"><code>LineSuffix</code></a> node into the print tree. The contents of the node are determined by the block.</p>

          <div class="method-source-code" id="line_suffix-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 1027</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_suffix</span>(<span class="ruby-value">priority:</span> <span class="ruby-constant">LineSuffix</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_PRIORITY</span>)
  <span class="ruby-identifier">doc</span> = <span class="ruby-constant">LineSuffix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">priority:</span> <span class="ruby-identifier">priority</span>)
  <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>

  <span class="ruby-identifier">with_target</span>(<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>) { <span class="ruby-keyword">yield</span> }
  <span class="ruby-identifier">doc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-nest" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">nest</span><span
            class="method-args">(indent) { || ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Increases left margin after newline with <code>indent</code> for line breaks added in the block.</p>

          <div class="method-source-code" id="nest-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 1037</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nest</span>(<span class="ruby-identifier">indent</span>)
  <span class="ruby-identifier">doc</span> = <span class="ruby-constant">Align</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">indent:</span> <span class="ruby-identifier">indent</span>)
  <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>

  <span class="ruby-identifier">with_target</span>(<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">contents</span>) { <span class="ruby-keyword">yield</span> }
  <span class="ruby-identifier">doc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-text" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">text</span><span
            class="method-args">(object = &quot;&quot;, width = object.length)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>This adds <code>object</code> as a text of <code>width</code> columns in width.</p>

<p>If <code>width</code> is not specified, object.length is used.</p>

          <div class="method-source-code" id="text-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 1048</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">text</span>(<span class="ruby-identifier">object</span> = <span class="ruby-string">&quot;&quot;</span>, <span class="ruby-identifier">width</span> = <span class="ruby-identifier">object</span>.<span class="ruby-identifier">length</span>)
  <span class="ruby-identifier">doc</span> = <span class="ruby-identifier">target</span>.<span class="ruby-identifier">last</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-constant">Text</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">doc</span>
    <span class="ruby-identifier">doc</span> = <span class="ruby-constant">Text</span>.<span class="ruby-identifier">new</span>
    <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">add</span>(<span class="ruby-value">object:</span> <span class="ruby-identifier">object</span>, <span class="ruby-value">width:</span> <span class="ruby-identifier">width</span>)
  <span class="ruby-identifier">doc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-trim" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">trim</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>This inserts a <a href="PrettyPrint/Trim.html"><code>Trim</code></a> node into the print tree which, when printed, will clear all whitespace at the end of the output buffer. This is useful for the rare case where you need to delete printed indentation and force the next node to start at the beginning of the line.</p>

          <div class="method-source-code" id="trim-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 935</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trim</span>
  <span class="ruby-identifier">doc</span> = <span class="ruby-constant">Trim</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">doc</span>

  <span class="ruby-identifier">doc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-with_target" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">with_target</span><span
            class="method-args">(target) { || ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>A convenience method used by a lot of the print tree node builders that temporarily changes the target that the builders will append to.</p>

          <div class="method-source-code" id="with_target-source">
            <pre><span class="ruby-comment"># File lib/syntax_tree/prettyprint.rb, line 1066</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_target</span>(<span class="ruby-identifier">target</span>)
  <span class="ruby-identifier">previous_target</span>, <span class="ruby-ivar">@target</span> = <span class="ruby-ivar">@target</span>, <span class="ruby-identifier">target</span>
  <span class="ruby-keyword">yield</span>
  <span class="ruby-ivar">@target</span> = <span class="ruby-identifier">previous_target</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

